package com.mattworzala.canary.codegen.genspec;


import com.google.auto.service.AutoService;
import com.squareup.javapoet.*;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

import static com.mattworzala.canary.codegen.PackageConstants.*;

@AutoService(Processor.class)
@SupportedSourceVersion(SourceVersion.RELEASE_17)
@SupportedAnnotationTypes(PKG_ASSERTION_SPEC + ".GenSpec")
public class GenSpecAP extends AbstractProcessor {
    private static boolean isRoundOne = true;

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        // We do not want to do any processing on rounds after the very first. If more GenSpec annotations were created thats not good.
        //todo could error out here instead (if there are any results inside `annotations`)
        if (!isRoundOne) return false;
        processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Compiling Canary GenSpec...");

        // Ok to get the first one since `annotations` will never contain more than one of the same type.
        // Since we only request @GenSpec here, that will always be the first element. If there are none,
        // then we do nothing.
        var maybeAnnotation = annotations.stream().findFirst();
        if (maybeAnnotation.isEmpty()) return false;
        TypeElement annotation = maybeAnnotation.get();

        List<TypeSpec> generatedAssertions = new ArrayList<>();

        // Generate the AssertionImpl class for each element annotated.
        // This fits into gradle's `isolating` processor mode (where it takes one input to create one output)
        for (Element type : roundEnv.getElementsAnnotatedWith(annotation)) {
//            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "GenSpec processing " + type);

            // Attempt to run our GenSpec processor on the class and write the output.
            try {
                TypeSpec.Builder typeSpec = type.accept(new GenSpecProcessor(processingEnv.getMessager()), null);
                if (typeSpec == null) {
                    return true;
                } // Return immediately, we have already errored inside the processor.

                TypeSpec javaType = typeSpec.build();
                generatedAssertions.add(javaType);
                JavaFile file = JavaFile.builder(PKG_ASSERTION_IMPL, javaType)
                        .addFileComment("AUTOGENERATED SOURCE FILE")
                        .indent("    ")
                        .build();

                file.writeTo(processingEnv.getFiler());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        // Generate the aggregate Assertions class for the api (hides the awful generic types)
        // This requires us to use gradle `aggregating` AP mode since we are not doing a 1:1 generation.
        try {
            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Creating aggregate assertion class from GenSpec results...");
            TypeSpec agg = generateAggregateAssertionClass(generatedAssertions);

            JavaFile file = JavaFile.builder(PKG_API, agg)
                    .addFileComment("AUTOGENERATED SOURCE FILE")
                    .indent("    ")
                    .build();
            file.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return true;
    }

    private TypeSpec generateAggregateAssertionClass(List<TypeSpec> assertionClasses) {
        TypeSpec.Builder typeSpec = TypeSpec.classBuilder("Assertions")
                .addModifiers(Modifier.PUBLIC);

        for (TypeSpec rawAssertionClass : assertionClasses) {
            // Name without the `Impl` suffix
            String className = rawAssertionClass.name.substring(0, rawAssertionClass.name.length() - 4);
            TypeSpec.Builder assertionClass = TypeSpec.classBuilder(className)
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC);

            // Superclass
            ParameterizedTypeName superClass = ParameterizedTypeName.get(
                    ClassName.get(PKG_ASSERTION_IMPL, rawAssertionClass.name), // AssertionImpl
                    getFirstTypeVariableBound(rawAssertionClass.typeVariables.get(0)),      // T
                    ClassName.get(PKG_API, "Assertions", className) // This
            );
            assertionClass.superclass(superClass);

            // Copied Constructor
            MethodSpec superConstructor = rawAssertionClass.methodSpecs.get(0);
            assertionClass.addMethod(MethodSpec.constructorBuilder()
                    .addModifiers(Modifier.PUBLIC)
                    .addParameters(superConstructor.parameters)
                    .addCode(superConstructor.code)
                    .build());

            typeSpec.addType(assertionClass.build());
        }

        return typeSpec.build();
    }

    private TypeName getFirstTypeVariableBound(TypeVariableName typeVariable) {
        List<TypeName> bounds = typeVariable.bounds;
        if (bounds.size() == 0) {
            return TypeName.get(Object.class);
        }
        return bounds.get(0);
    }
}
