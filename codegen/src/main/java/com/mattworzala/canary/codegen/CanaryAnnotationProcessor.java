package com.mattworzala.canary.codegen;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * Annotation processor with a few assumptions and utilities.
 * <p>
 * Assumptions
 * <ul>
 *     <li>Only one annotation is given in {@link javax.annotation.processing.SupportedAnnotationTypes}</li>
 *     <li>All files are emitted using {@link #emitFile(String, TypeSpec)}</li>
 * </ul>
 */
public abstract class CanaryAnnotationProcessor extends AbstractProcessor {
    protected Logger logger;

    /**
     * Processes a single element in isolation. `isolating` APs should exclusively implement this method.
     *
     * @param element The element to process
     */
    public void process(Element element) {}

    /**
     * Processes a collection of elements. `aggregating` APs may implement this method.
     *
     * @param elements The elements to process
     */
    public void process(Collection<? extends Element> elements) {
        elements.forEach(this::process);
    }

    // Supporting methods

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);

        logger = new Logger(processingEnv.getMessager());
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

        // Ok to get the first one since `annotations` will never contain more than one of the same type.
        // If there are none, then we do nothing.
        var maybeAnnotation = annotations.stream().findFirst();
        if (maybeAnnotation.isEmpty()) return false;
        TypeElement annotation = maybeAnnotation.get();

        // Process the elements
        process(roundEnv.getElementsAnnotatedWith(annotation));

        // Allow future processors to handle the same annotation
        return false;
    }

    protected void emitFile(String pkg, TypeSpec type) {
        try {
            JavaFile file = JavaFile.builder(pkg, type)
                    .addFileComment("AUTOGENERATED SOURCE FILE (Codegen v$CODEGEN_VERSION$)")
                    .indent("    ")
                    .build();

            file.writeTo(processingEnv.getFiler());
        } catch (IOException e) {
            logger.error(e.getMessage());
        }
    }

    public static record Logger(Messager messager) {
        public void info(String message) {
            messager().printMessage(Diagnostic.Kind.NOTE, message);
        }

        public void error(String message) {
            messager().printMessage(Diagnostic.Kind.ERROR, message);
        }

        public void error(String message, Element element) {
            messager().printMessage(Diagnostic.Kind.ERROR, message, element);
        }
    }




}
